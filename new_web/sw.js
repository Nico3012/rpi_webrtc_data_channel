// Dynamically generated by the Go backend at /sw.js
// IMPORTANT: restart the go server to pick up template changes if embedded.

const CACHE_NAME = {{ .CacheNameJSON }};
const RESOURCES = {{ .ResourcesJSON }};
const INDEX_HTML_HANDLER = true;

self.addEventListener('install', (event) => {
	event.waitUntil(
		(async () => {
			if (await caches.has(CACHE_NAME)) {
				console.log('Cache already exists, skipping install.');
				return;
			}
			const cache = await caches.open(CACHE_NAME);
			for (const pathname of RESOURCES) {
				const response = await fetch(pathname, { redirect: 'manual' });
				await cache.put(pathname, response.clone());
				console.log(`Cached: ${pathname}`);
			}
		})()
	);
});

self.addEventListener('activate', (event) => {
	event.waitUntil(
		(async () => {
			const names = await caches.keys();
			await Promise.all(names.map((name) => (name === CACHE_NAME ? Promise.resolve(false) : caches.delete(name))));
		})()
	);
});

self.addEventListener('fetch', (event) => {
	event.respondWith((async () => {
		const request = event.request;
		const url = new URL(request.url);

		// Allow external URLs to pass through (CDN resources, etc.)
		if (url.origin !== self.location.origin) return await fetch(request);

		// Only handle GET requests; everything else passes through
		if (request.method !== 'GET') return await fetch(request);

		// if cache is not available, bypass the service worker!
		if (!(await caches.has(CACHE_NAME))) return await fetch(request);

		const cache = await caches.open(CACHE_NAME);

		// static routing server (Go http.FileServer compatible)

		if (!INDEX_HTML_HANDLER || !url.pathname.endsWith('/index.html')) {
			const response = await cache.match(url.pathname);

			if (response) {

				// Handle Range requests
				const rangeHeader = request.headers.get('Range');
				if (rangeHeader && rangeHeader.startsWith('bytes=')) {
					const m = rangeHeader.match(/bytes=(\d*)-(\d*)/);
					const size = parseInt(response.headers.get('Content-Length')) || 0;
					let start = m[1] ? parseInt(m[1]) : 0;
					let end = m[2] ? parseInt(m[2]) : (size ? size - 1 : 0);

					if (isNaN(start) || start < 0) start = 0;
					if (isNaN(end) || end >= size) end = size - 1;
					if (end < start) end = size - 1;

					const chunkSize = end - start + 1;
					const headers = new Headers(response.headers);
					headers.set('Content-Range', `bytes ${start}-${end}/${size}`);
					headers.set('Content-Length', chunkSize);
					headers.set('Accept-Ranges', 'bytes');

					const stream = new ReadableStream({
						async start(controller) {
							const reader = response.body.getReader();
							let bytesSkipped = 0;
							let bytesSent = 0;

							while (true) {
								const { value, done } = await reader.read();
								if (done) break;

								const chunk = value;
								const chunkLength = chunk.byteLength;

								if (bytesSkipped + chunkLength <= start) {
									// skip entire chunk
									bytesSkipped += chunkLength;
									continue;
								}

								let sliceStart = 0;
								if (bytesSkipped < start) {
									sliceStart = start - bytesSkipped;
								}

								const available = chunkLength - sliceStart;
								const bytesRemaining = chunkSize - bytesSent;
								const bytesToSend = Math.min(available, bytesRemaining);

								controller.enqueue(chunk.slice(sliceStart, sliceStart + bytesToSend));
								bytesSent += bytesToSend;
								bytesSkipped += chunkLength;

								if (bytesSent >= chunkSize) break;
							}

							controller.close();
						}
					});

					return new Response(stream, {
						status: 206,
						statusText: 'Partial Content',
						headers
					});
				} else {
					return response;
				}

			} else {
				return new Response('404 page not found', { status: 404 });
			}
		} else {
			// always remove index.html to cleanup pathname (like go http.FileServer does)
			return Response.redirect(url.pathname.slice(0, -10) + url.search, 301);
		}
	})());
});
